{"ast":null,"code":"import axios from 'axios';\nconst api = axios.create({\n  baseURL: '/api',\n  timeout: 30000,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\napi.interceptors.request.use(config => {\n  var _config$method;\n  console.log(`ðŸš€ ${(_config$method = config.method) === null || _config$method === void 0 ? void 0 : _config$method.toUpperCase()} ${config.url}`, config.data || config.params);\n  return config;\n}, error => {\n  console.error('âŒ Request Error:', error);\n  return Promise.reject(error);\n});\napi.interceptors.response.use(response => {\n  var _response$config$meth;\n  console.log(`âœ… ${(_response$config$meth = response.config.method) === null || _response$config$meth === void 0 ? void 0 : _response$config$meth.toUpperCase()} ${response.config.url}`, response.data);\n  return response;\n}, error => {\n  var _error$response, _error$response2, _error$response3, _error$response4;\n  console.error('âŒ Response Error:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n  if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 404) {\n    throw new Error('Resource not found');\n  } else if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 400) {\n    throw new Error(error.response.data.message || 'Invalid request');\n  } else if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 500) {\n    throw new Error('Server error occurred');\n  } else if (error.code === 'ECONNABORTED') {\n    throw new Error('Request timeout - please try again');\n  }\n  throw error;\n});\nexport const apiService = {\n  // Spill Endpoints - Return data directly\n  async getAllSpills() {\n    const response = await api.get('/dispersion/spills/all');\n    return response.data;\n  },\n  async getActiveSpills() {\n    const response = await api.get('/dispersion/spills');\n    return response.data;\n  },\n  async createSpill(spillData) {\n    const response = await api.post('/dispersion/spills', spillData);\n    return response.data;\n  },\n  async updateSpillStatus(spillId, status) {\n    const response = await api.put(`/dispersion/spills/${spillId}/status`, null, {\n      params: {\n        status\n      }\n    });\n    return response.data;\n  },\n  async calculateDispersion(spillId, simulationHours = 24) {\n    const response = await api.post(`/dispersion/spills/${spillId}/calculate`, null, {\n      params: {\n        simulationHours\n      }\n    });\n    return response.data;\n  },\n  async deleteSpill(spillId) {\n    const response = await api.delete(`/dispersion/spills/${spillId}`);\n    return response.data;\n  },\n  // System Status\n  async getSystemStatus() {\n    const response = await api.get('/dispersion/status');\n    return response.data;\n  },\n  // Weather Endpoints - FIXED with better error handling\n  async getCurrentWeather(latitude, longitude) {\n    try {\n      const response = await api.get('/weather/current', {\n        params: {\n          latitude,\n          longitude\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.warn('Weather API unavailable, using mock data');\n      // Return mock weather data\n      return {\n        temperature: 22.0 + (Math.random() - 0.5) * 10,\n        windSpeed: 5.0 + Math.random() * 10,\n        windDirection: Math.random() * 360,\n        humidity: 60.0 + Math.random() * 30,\n        pressure: 1013.25 + (Math.random() - 0.5) * 20,\n        visibility: 10.0,\n        weatherCondition: ['Partly Cloudy', 'Clear', 'Overcast', 'Light Rain'][Math.floor(Math.random() * 4)],\n        timestamp: new Date().toISOString()\n      };\n    }\n  },\n  async getWeatherForecast(latitude, longitude, hours = 72) {\n    try {\n      const response = await api.get('/weather/forecast', {\n        params: {\n          latitude,\n          longitude,\n          hoursAhead: hours\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.warn('Weather forecast unavailable');\n      return [];\n    }\n  },\n  // Tide Endpoints - FIXED with better mock data\n  async getTidalData(latitude, longitude, hours = 72) {\n    try {\n      const response = await api.get('/tides/forecast', {\n        params: {\n          latitude,\n          longitude,\n          hoursAhead: hours\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.warn('Tidal API unavailable, using mock data');\n      return [{\n        tideHeight: 1.0 + Math.random() * 2,\n        currentSpeed: 0.1 + Math.random() * 0.8,\n        currentDirection: Math.random() * 360,\n        time: new Date().toISOString(),\n        station: 'Mock Station'\n      }];\n    }\n  },\n  async getTideForecast(latitude, longitude, hours = 72) {\n    return this.getTidalData(latitude, longitude, hours);\n  },\n  // Chemical Properties - Enhanced with better error handling\n  async getChemicalData(chemicalName) {\n    try {\n      const response = await api.get(`/dispersion/chemicals/${encodeURIComponent(chemicalName)}`);\n      return response.data;\n    } catch (error) {\n      console.warn(`Chemical data not found for ${chemicalName}`);\n      return null;\n    }\n  },\n  async storeChemicalData(chemicalData) {\n    try {\n      const response = await api.post('/dispersion/chemicals', chemicalData);\n      return response.data;\n    } catch (error) {\n      console.warn('Failed to store chemical data:', error);\n      throw error;\n    }\n  },\n  async getChemicalProperties(chemicalName) {\n    return this.getChemicalData(chemicalName);\n  },\n  // Real-time updates endpoint - Enhanced with better connection handling\n  subscribeToUpdates(onUpdate) {\n    let eventSource = null;\n    let reconnectTimer = null;\n    let reconnectAttempts = 0;\n    const maxReconnectAttempts = 5;\n    const connect = () => {\n      try {\n        eventSource = new EventSource('/api/real-time-updates');\n        eventSource.onmessage = event => {\n          try {\n            const data = JSON.parse(event.data);\n            onUpdate(data);\n            reconnectAttempts = 0; // Reset on successful message\n          } catch (error) {\n            console.error('Error parsing SSE data:', error);\n          }\n        };\n        eventSource.onopen = () => {\n          console.log('SSE connected successfully');\n          reconnectAttempts = 0;\n        };\n        eventSource.onerror = error => {\n          console.error('EventSource failed:', error);\n          eventSource.close();\n\n          // Attempt to reconnect with exponential backoff\n          if (reconnectAttempts < maxReconnectAttempts) {\n            const delay = Math.pow(2, reconnectAttempts) * 1000; // Exponential backoff\n            reconnectAttempts++;\n            console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts})`);\n            reconnectTimer = setTimeout(() => {\n              connect();\n            }, delay);\n          } else {\n            console.error('Max reconnection attempts reached');\n          }\n        };\n      } catch (error) {\n        console.error('Failed to establish SSE connection:', error);\n      }\n    };\n    connect();\n\n    // Return cleanup function\n    return () => {\n      if (eventSource) {\n        eventSource.close();\n      }\n      if (reconnectTimer) {\n        clearTimeout(reconnectTimer);\n      }\n    };\n  },\n  // Utility functions\n  async retryRequest(requestFunction, maxRetries = 3, delay = 1000) {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await requestFunction();\n      } catch (error) {\n        if (attempt === maxRetries) {\n          throw error;\n        }\n        console.warn(`Retrying API call (${attempt}/${maxRetries}) in ${delay}ms...`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n        delay *= 2;\n      }\n    }\n  },\n  formatCoordinates(lat, lng, precision = 6) {\n    return {\n      latitude: parseFloat(lat.toFixed(precision)),\n      longitude: parseFloat(lng.toFixed(precision))\n    };\n  },\n  validateSpillData(spillData) {\n    const required = ['name', 'chemicalType', 'volume', 'latitude', 'longitude', 'spillTime'];\n    const errors = [];\n    for (const field of required) {\n      if (!spillData[field]) errors.push(`${field} is required`);\n    }\n    if (spillData.volume && spillData.volume <= 0) errors.push('Volume must be positive');\n    if (spillData.latitude && (spillData.latitude < -90 || spillData.latitude > 90)) {\n      errors.push('Latitude must be between -90 and 90');\n    }\n    if (spillData.longitude && (spillData.longitude < -180 || spillData.longitude > 180)) {\n      errors.push('Longitude must be between -180 and 180');\n    }\n    return errors;\n  },\n  // Enhanced environmental data fetching\n  async getEnvironmentalData(latitude, longitude) {\n    try {\n      const [weather, tides] = await Promise.allSettled([this.getCurrentWeather(latitude, longitude), this.getTideForecast(latitude, longitude, 24)]);\n      return {\n        weather: weather.status === 'fulfilled' ? weather.value : null,\n        tides: tides.status === 'fulfilled' ? tides.value : null,\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      console.error('Error fetching environmental data:', error);\n      throw error;\n    }\n  }\n};","map":{"version":3,"names":["axios","api","create","baseURL","timeout","headers","interceptors","request","use","config","_config$method","console","log","method","toUpperCase","url","data","params","error","Promise","reject","response","_response$config$meth","_error$response","_error$response2","_error$response3","_error$response4","message","status","Error","code","apiService","getAllSpills","get","getActiveSpills","createSpill","spillData","post","updateSpillStatus","spillId","put","calculateDispersion","simulationHours","deleteSpill","delete","getSystemStatus","getCurrentWeather","latitude","longitude","warn","temperature","Math","random","windSpeed","windDirection","humidity","pressure","visibility","weatherCondition","floor","timestamp","Date","toISOString","getWeatherForecast","hours","hoursAhead","getTidalData","tideHeight","currentSpeed","currentDirection","time","station","getTideForecast","getChemicalData","chemicalName","encodeURIComponent","storeChemicalData","chemicalData","getChemicalProperties","subscribeToUpdates","onUpdate","eventSource","reconnectTimer","reconnectAttempts","maxReconnectAttempts","connect","EventSource","onmessage","event","JSON","parse","onopen","onerror","close","delay","pow","setTimeout","clearTimeout","retryRequest","requestFunction","maxRetries","attempt","resolve","formatCoordinates","lat","lng","precision","parseFloat","toFixed","validateSpillData","required","errors","field","push","volume","getEnvironmentalData","weather","tides","allSettled","value"],"sources":["C:/water/chemical-dispersion-app/frontend/src/services/api.js"],"sourcesContent":["import axios from 'axios';\n\nconst api = axios.create({\n    baseURL: '/api',\n    timeout: 30000,\n    headers: {\n        'Content-Type': 'application/json',\n    },\n});\n\napi.interceptors.request.use(\n    (config) => {\n        console.log(`ðŸš€ ${config.method?.toUpperCase()} ${config.url}`, config.data || config.params);\n        return config;\n    },\n    (error) => {\n        console.error('âŒ Request Error:', error);\n        return Promise.reject(error);\n    }\n);\n\napi.interceptors.response.use(\n    (response) => {\n        console.log(`âœ… ${response.config.method?.toUpperCase()} ${response.config.url}`, response.data);\n        return response;\n    },\n    (error) => {\n        console.error('âŒ Response Error:', error.response?.data || error.message);\n        if (error.response?.status === 404) {\n            throw new Error('Resource not found');\n        } else if (error.response?.status === 400) {\n            throw new Error(error.response.data.message || 'Invalid request');\n        } else if (error.response?.status === 500) {\n            throw new Error('Server error occurred');\n        } else if (error.code === 'ECONNABORTED') {\n            throw new Error('Request timeout - please try again');\n        }\n        throw error;\n    }\n);\n\nexport const apiService = {\n    // Spill Endpoints - Return data directly\n    async getAllSpills() {\n        const response = await api.get('/dispersion/spills/all');\n        return response.data;\n    },\n\n    async getActiveSpills() {\n        const response = await api.get('/dispersion/spills');\n        return response.data;\n    },\n\n    async createSpill(spillData) {\n        const response = await api.post('/dispersion/spills', spillData);\n        return response.data;\n    },\n\n    async updateSpillStatus(spillId, status) {\n        const response = await api.put(`/dispersion/spills/${spillId}/status`, null, {\n            params: { status }\n        });\n        return response.data;\n    },\n\n    async calculateDispersion(spillId, simulationHours = 24) {\n        const response = await api.post(`/dispersion/spills/${spillId}/calculate`, null, {\n            params: { simulationHours }\n        });\n        return response.data;\n    },\n\n    async deleteSpill(spillId) {\n        const response = await api.delete(`/dispersion/spills/${spillId}`);\n        return response.data;\n    },\n\n    // System Status\n    async getSystemStatus() {\n        const response = await api.get('/dispersion/status');\n        return response.data;\n    },\n\n    // Weather Endpoints - FIXED with better error handling\n    async getCurrentWeather(latitude, longitude) {\n        try {\n            const response = await api.get('/weather/current', {\n                params: { latitude, longitude }\n            });\n            return response.data;\n        } catch (error) {\n            console.warn('Weather API unavailable, using mock data');\n            // Return mock weather data\n            return {\n                temperature: 22.0 + (Math.random() - 0.5) * 10,\n                windSpeed: 5.0 + Math.random() * 10,\n                windDirection: Math.random() * 360,\n                humidity: 60.0 + Math.random() * 30,\n                pressure: 1013.25 + (Math.random() - 0.5) * 20,\n                visibility: 10.0,\n                weatherCondition: ['Partly Cloudy', 'Clear', 'Overcast', 'Light Rain'][Math.floor(Math.random() * 4)],\n                timestamp: new Date().toISOString()\n            };\n        }\n    },\n\n    async getWeatherForecast(latitude, longitude, hours = 72) {\n        try {\n            const response = await api.get('/weather/forecast', {\n                params: { latitude, longitude, hoursAhead: hours }\n            });\n            return response.data;\n        } catch (error) {\n            console.warn('Weather forecast unavailable');\n            return [];\n        }\n    },\n\n    // Tide Endpoints - FIXED with better mock data\n    async getTidalData(latitude, longitude, hours = 72) {\n        try {\n            const response = await api.get('/tides/forecast', {\n                params: { latitude, longitude, hoursAhead: hours }\n            });\n            return response.data;\n        } catch (error) {\n            console.warn('Tidal API unavailable, using mock data');\n            return [{\n                tideHeight: 1.0 + Math.random() * 2,\n                currentSpeed: 0.1 + Math.random() * 0.8,\n                currentDirection: Math.random() * 360,\n                time: new Date().toISOString(),\n                station: 'Mock Station'\n            }];\n        }\n    },\n\n    async getTideForecast(latitude, longitude, hours = 72) {\n        return this.getTidalData(latitude, longitude, hours);\n    },\n\n    // Chemical Properties - Enhanced with better error handling\n    async getChemicalData(chemicalName) {\n        try {\n            const response = await api.get(`/dispersion/chemicals/${encodeURIComponent(chemicalName)}`);\n            return response.data;\n        } catch (error) {\n            console.warn(`Chemical data not found for ${chemicalName}`);\n            return null;\n        }\n    },\n\n    async storeChemicalData(chemicalData) {\n        try {\n            const response = await api.post('/dispersion/chemicals', chemicalData);\n            return response.data;\n        } catch (error) {\n            console.warn('Failed to store chemical data:', error);\n            throw error;\n        }\n    },\n\n    async getChemicalProperties(chemicalName) {\n        return this.getChemicalData(chemicalName);\n    },\n\n    // Real-time updates endpoint - Enhanced with better connection handling\n    subscribeToUpdates(onUpdate) {\n        let eventSource = null;\n        let reconnectTimer = null;\n        let reconnectAttempts = 0;\n        const maxReconnectAttempts = 5;\n\n        const connect = () => {\n            try {\n                eventSource = new EventSource('/api/real-time-updates');\n                \n                eventSource.onmessage = (event) => {\n                    try {\n                        const data = JSON.parse(event.data);\n                        onUpdate(data);\n                        reconnectAttempts = 0; // Reset on successful message\n                    } catch (error) {\n                        console.error('Error parsing SSE data:', error);\n                    }\n                };\n\n                eventSource.onopen = () => {\n                    console.log('SSE connected successfully');\n                    reconnectAttempts = 0;\n                };\n\n                eventSource.onerror = (error) => {\n                    console.error('EventSource failed:', error);\n                    eventSource.close();\n                    \n                    // Attempt to reconnect with exponential backoff\n                    if (reconnectAttempts < maxReconnectAttempts) {\n                        const delay = Math.pow(2, reconnectAttempts) * 1000; // Exponential backoff\n                        reconnectAttempts++;\n                        console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts})`);\n                        \n                        reconnectTimer = setTimeout(() => {\n                            connect();\n                        }, delay);\n                    } else {\n                        console.error('Max reconnection attempts reached');\n                    }\n                };\n\n            } catch (error) {\n                console.error('Failed to establish SSE connection:', error);\n            }\n        };\n\n        connect();\n\n        // Return cleanup function\n        return () => {\n            if (eventSource) {\n                eventSource.close();\n            }\n            if (reconnectTimer) {\n                clearTimeout(reconnectTimer);\n            }\n        };\n    },\n\n    // Utility functions\n    async retryRequest(requestFunction, maxRetries = 3, delay = 1000) {\n        for (let attempt = 1; attempt <= maxRetries; attempt++) {\n            try {\n                return await requestFunction();\n            } catch (error) {\n                if (attempt === maxRetries) {\n                    throw error;\n                }\n                console.warn(`Retrying API call (${attempt}/${maxRetries}) in ${delay}ms...`);\n                await new Promise(resolve => setTimeout(resolve, delay));\n                delay *= 2;\n            }\n        }\n    },\n\n    formatCoordinates(lat, lng, precision = 6) {\n        return {\n            latitude: parseFloat(lat.toFixed(precision)),\n            longitude: parseFloat(lng.toFixed(precision))\n        };\n    },\n\n    validateSpillData(spillData) {\n        const required = ['name', 'chemicalType', 'volume', 'latitude', 'longitude', 'spillTime'];\n        const errors = [];\n\n        for (const field of required) {\n            if (!spillData[field]) errors.push(`${field} is required`);\n        }\n\n        if (spillData.volume && spillData.volume <= 0) errors.push('Volume must be positive');\n        if (spillData.latitude && (spillData.latitude < -90 || spillData.latitude > 90)) {\n            errors.push('Latitude must be between -90 and 90');\n        }\n        if (spillData.longitude && (spillData.longitude < -180 || spillData.longitude > 180)) {\n            errors.push('Longitude must be between -180 and 180');\n        }\n\n        return errors;\n    },\n\n    // Enhanced environmental data fetching\n    async getEnvironmentalData(latitude, longitude) {\n        try {\n            const [weather, tides] = await Promise.allSettled([\n                this.getCurrentWeather(latitude, longitude),\n                this.getTideForecast(latitude, longitude, 24)\n            ]);\n\n            return {\n                weather: weather.status === 'fulfilled' ? weather.value : null,\n                tides: tides.status === 'fulfilled' ? tides.value : null,\n                timestamp: new Date().toISOString()\n            };\n        } catch (error) {\n            console.error('Error fetching environmental data:', error);\n            throw error;\n        }\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}